<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <title>Homework 3 - Rectangle Rubber Banding</title>
        <script type="text/javascript">
            mouse_over_canvas = true;
            drawn_shapes = {};
            page_margin = 8;

            current_index = 0;
            current_shape = 'rect';
            current_tool = 'scale';
            current_size = 0;

            draw = () => {
                canvas = document.getElementById('canvas');
                context = canvas.getContext('2d');

                mouse_is_pressed = false;
                set_current_shape(current_shape);
                display_size();
            }

            // mouse functions
            mouse_pressed = (event) => {
                if(mouse_over_canvas) {
                    x_pressed = event.clientX - page_margin;
                    y_pressed = event.clientY - page_margin;

                    mouse_is_pressed = true;

                    document.getElementById('mouse_pressed_x').innerHTML = x_pressed;
                    document.getElementById('mouse_pressed_y').innerHTML = y_pressed;
                    document.getElementById('status').innerHTML = mouse_is_pressed;
                }
            }

            mouse_move = (event) => {
                x_move = event.clientX - page_margin;
                y_move = event.clientY - page_margin;

                if(mouse_is_pressed) {
                    clear_canvas();
                    // draw_previous();

                    switch(current_shape) {
                        case "circ":
                            use_current_circ_tool();
                            break;
                        case "line":
                            use_current_line_tool();
                            break;
                        case "rect":
                            use_current_rect_tool();
                            
                            break;
                        default:
                            console.log("Error: no shape selected.");
                            break;
                    }
                }

                document.getElementById('mouse_move_x').innerHTML = x_move;
                document.getElementById('mouse_move_y').innerHTML = y_move;
                document.getElementById('status').innerHTML = mouse_is_pressed;
            }

            clear_canvas = () => {
                context.clearRect(0, 0, canvas.width, canvas.height);
            }

            // used for re-drawing previous shapes - not working with new implementation of saving
            draw_previous = () => {
                canvas_shapes.forEach((shape) => {
                    switch(shape[0]) {
                        case "circ":
                            circ_translation(shape[1][0], shape[1][1], shape[1][2], shape[1][3], shape[1][4], shape[1][5], shape[1][6], shape[1][7]);
                            break;
                        case "line":
                            line_translation(shape[1][0], shape[1][1], shape[1][2], shape[1][3], shape[1][4], shape[1][5]);
                            break;
                        case "rect":
                            rect_translation(shape[1][0], shape[1][1], shape[1][2], shape[1][3], shape[1][4], shape[1][5]);
                            break;
                        default:
                            console.log("Error: no shape definition.");
                            break;
                    }
                });
            }

            mouse_released = (event) => {
                x_released = event.clientX - page_margin;
                y_released = event.clientY - page_margin;

                mouse_is_pressed = false;
                
                document.getElementById('mouse_released_x').innerHTML = x_released;
                document.getElementById('mouse_released_y').innerHTML = y_released;
                document.getElementById('status').innerHTML = mouse_is_pressed;
            }

            // button functions
            set_current_shape = (shape) => {
                current_shape = shape;
            }

            set_current_tool = (tool) => {
                current_tool = tool;
            }

            disable_current_button = () => {
                let buttons = document.getElementsByTagName("button");
                
                for (let i = 0; i < buttons.length; ++i) {
                    if(buttons[i].value == current_shape || buttons[i].value == current_tool) {
                        buttons[i].disabled = true;
                    } else {
                        buttons[i].disabled = false;
                    }
                }
            }

            // shape functions
            // -- circles
            circ_translation = (x_origin, y_origin, x_radius, y_radius, starting_angle, ending_angle, mov_x, mov_y) => {
                let translation_matrix = [[1, 0, mov_x], [0, 1, mov_y], [0, 0, 1]];
                let origin_position_matrix = [[x_origin], [y_origin], [1]];
                let end_position_matrix = [[x_radius], [y_radius], [1]];

                let new_origin = matrix_mult(translation_matrix, origin_position_matrix);
                let new_end = matrix_mult(translation_matrix, end_position_matrix);
                
                context.beginPath();
                context.ellipse(new_origin[0][0], new_origin[1][0], new_end[0][0], new_end[1][0], 0, starting_angle, ending_angle, false);
                context.stroke();
            }

            circ_rotation = (x_origin, y_origin, x_radius, y_radius, rot) => {
                let rotation_matrix = [[Math.cos(rot), -1 * Math.sin(rot), 0],[Math.sin(rot), Math.cos(rot), 0], [0, 0, 1]];
                let origin_position_matrix = [[x_origin], [y_origin], [1]];
                let end_position_matrix = [[x_radius], [y_radius], [1]];

                let new_origin = matrix_mult(rotation_matrix, origin_position_matrix);
                let new_end = matrix_mult(rotation_matrix, end_position_matrix);

                context.beginPath();
                context.arc(new_origin[0][0], new_origin[1][0], end_position_matrix[0][0], 0, 2 * Math.PI);
                context.stroke();
            }

            use_current_circ_tool = () => {
                x_radius = Math.abs(x_move - x_pressed);
                y_radius = Math.abs(y_move - y_pressed);

                switch(current_tool) {
                    case "scale":
                        circ_translation(x_pressed, y_pressed, x_radius, y_radius, 0, 2 * Math.PI, 0, 0);
                        break;
                    case "rotate":
                        rotation = calculate_rotation(x_pressed, y_pressed, x_move, y_move); // already in radians, no need to convert
                        circ_rotation(x_pressed, y_pressed, current_size, current_size, rotation);
                        break;
                    case "translate":
                        circ_translation(x_move, y_move, current_size / 2, current_size / 2, 0, 2 * Math.PI, 0, 0);
                        break;
                    default:
                        break;
                }
            }

            // -- lines
            line_translation = (x_origin, y_origin, x_end, y_end, mov_x, mov_y) => {
                let translation_matrix = [[1, 0, mov_x], [0, 1, mov_y], [0, 0, 1]];
                let origin_position_matrix = [[x_origin], [y_origin], [1]];
                let end_position_matrix = [[x_end], [y_end], [1]];

                let new_origin = matrix_mult(translation_matrix, origin_position_matrix);
                let new_end = matrix_mult(translation_matrix, end_position_matrix);

                context.beginPath();
                context.moveTo(new_origin[0][0], new_origin[1][0]);
                context.lineTo(new_end[0][0], new_end[1][0]);
                context.stroke();
            }

            line_rotation = (x_origin, y_origin, x_end, y_end, rot) => {
                let rotation_matrix = [[Math.cos(rot), -1 * Math.sin(rot), 0],[Math.sin(rot), Math.cos(rot), 0], [0, 0, 1]];
                let origin_position_matrix = [[0], [0], [1]];
                let end_position_matrix = [[x_end-x_origin], [y_end-y_origin], [1]];

                let new_origin = matrix_mult(rotation_matrix, origin_position_matrix);
                let new_end = matrix_mult(rotation_matrix, end_position_matrix);

                context.beginPath();
                context.moveTo(new_origin[0][0], new_origin[1][0]);
                context.lineTo(new_end[0][0], new_end[1][0]);
                context.stroke();
            }

            new_rotation_arbitrary_point = (x_origin, y_origin, x_end, y_end, mov_x, mov_y, rot) => {
                line_translation(x_origin, y_origin, x_end, y_end, -mov_x, -mov_y);
                line_rotation(x_origin, y_origin, x_end, y_end, rot);
                line_translation(x_origin, y_origin, x_end, y_end, mov_x, mov_y);
            }
            
            line_rotation_arbitrary_point = (x_origin, y_origin, x_end, y_end, rot) => {
                let origin_position_matrix = [
                    [x_origin], 
                    [y_origin],
                    [1]
                ];

                let end_position_matrix = [
                    [x_end], 
                    [y_end],
                    [1]
                ];
                
                let origin_arbitrary_point_rotation_matrix = [
                    [Math.cos(rot),                                                        Math.sin(rot),                                                       0],
                    [-1 * Math.sin(rot),                                                   Math.cos(rot),                                                       0],
                    [-1 * x_origin * Math.cos(rot) + y_origin * Math.sin(rot) + x_origin,  -1 * x_origin * Math.sin(rot) - y_origin * Math.cos(rot) + y_origin, 1]
                ];
                
                let end_arbitrary_point_rotation_matrix = [
                    [Math.cos(rot),                                                        Math.sin(rot),                                                       0],
                    [-1 * Math.sin(rot),                                                   Math.cos(rot),                                                       0],
                    [-1 * x_end * Math.cos(rot) + y_end * Math.sin(rot) + x_end,  -1 * x_end * Math.sin(rot) - y_end * Math.cos(rot) + y_end, 1]
                ];
                
                let new_origin = matrix_mult(origin_position_matrix, origin_arbitrary_point_rotation_matrix);
                let new_end = matrix_mult(end_position_matrix, origin_arbitrary_point_rotation_matrix);

                context.beginPath();
                context.moveTo(new_origin[0][0], new_origin[1][0]);
                context.lineTo(new_end[0][0], new_end[1][0]);
                context.stroke();
            }

            use_current_line_tool = () => {
                switch(current_tool) {
                    case "scale":
                        line_translation(x_pressed, y_pressed, x_move, y_move, 0, 0);
                        break;
                    case "rotate":
                        rotation = calculate_rotation(x_pressed, y_pressed, x_move, y_move); // already in radians, no need to convert
                        new_rotation_arbitrary_point(x_pressed, y_pressed, x_pressed + parseInt(current_size), y_pressed + parseInt(current_size), x_pressed, y_pressed, rotation);
                        break;
                    case "translate":
                        line_translation(x_move, y_move, x_move + parseInt(current_size), y_move + parseInt(current_size), 0, 0);
                        break;
                    default:
                        break;
                }
            }

            // -- rectangles
            rect_translation = (x_origin, y_origin, width, height, mov_x, mov_y) => {
                let translation_matrix = [[1, 0, mov_x], [0, 1, mov_y], [0, 0, 1]];
                let origin_position_matrix = [[x_origin], [y_origin], [1]];

                let new_origin = matrix_mult(translation_matrix, origin_position_matrix);

                context.strokeRect(new_origin[0][0], new_origin[1][0], width, height);
            }

            rect_rotation = (x0, y0, x1, y1, x2, y2, x3, y3, rot) => {
                let rotation_matrix = [[Math.cos(rot), -1 * Math.sin(rot), 0],[Math.sin(rot), Math.cos(rot), 0], [0, 0, 1]];
                let top_left_matrix = [[x0], [y0], [1]];
                let top_right_matrix = [[x1], [y1], [1]];
                let bottom_left_matrix = [[x3], [y3], [1]];
                let bottom_right_matrix = [[x2], [y2], [1]];

                let new_top_left = matrix_mult(rotation_matrix, top_left_matrix);
                let new_top_right = matrix_mult(rotation_matrix, top_right_matrix);
                let new_bottom_left = matrix_mult(rotation_matrix, bottom_left_matrix);
                let new_bottom_right = matrix_mult(rotation_matrix, bottom_right_matrix);

                custom_rect(new_top_left[0][0], new_top_left[1][0], new_top_right[0][0], new_top_right[1][0], new_bottom_right[0][0], new_bottom_right[1][0], new_bottom_left[0][0], new_bottom_left[1][0]);
            }

            use_current_rect_tool = () => {
                width = x_move - x_pressed;
                height = y_move - y_pressed;

                switch(current_tool) {
                    case "scale":
                        rect_translation(x_pressed, y_pressed, width, height, 0, 0);
                        break;
                    case "rotate":
                        rotation = calculate_rotation(x_pressed, y_pressed, x_move, y_move); // already in radians, no need to convert
                        rect_rotation(x_pressed, y_pressed, x_pressed + parseInt(current_size), y_pressed, x_pressed + parseInt(current_size), y_pressed + parseInt(current_size), x_pressed, y_pressed + parseInt(current_size), rotation);
                        break;
                    case "translate":
                        rect_translation(x_move, y_move, current_size, current_size, 0, 0);
                        break;
                    default:
                        break;
                }
            }

            // extras
            // -- found this at: https://stackoverflow.com/questions/21483999/using-atan2-to-find-angle-between-two-vectors#answer-21484228
            calculate_rotation = (x0, y0, x1, y1) => {
                return Math.atan2(y1 - y0, x1 - x0);
            }

            custom_rect = (x0, y0, x1, y1, x2, y2, x3, y3) => {
                context.beginPath();

                // top
                context.moveTo(x0, y0);
                context.lineTo(x1, y1);
                context.stroke();

                // right
                context.moveTo(x1, y1);
                context.lineTo(x2, y2);
                context.stroke();

                // bottom
                context.moveTo(x2, y2);
                context.lineTo(x3, y3);
                context.stroke();

                // left
                context.moveTo(x3, y3);
                context.lineTo(x0, y0);
                context.stroke();
            }

            degrees_to_radians = (degrees) => {
                return degrees * Math.PI / 180;
            }

            display_size = (size) => {
                document.getElementById('shape-size-output').innerHTML = document.getElementById('shape-size-input').value;
                current_size = document.getElementById('shape-size-input').value;
            }

            draw_pixel = (x, y) => {
                context.strokeRect(x, y, 1, 1);
            }

            matrix_mult = (a, b) => {
                let a_num_rows = a.length;
                let a_num_cols = a[0].length;
                let b_num_cols = b[0].length;
                let m = new Array(a_num_rows);

                for (let r = 0; r < a_num_rows; ++r) {
                    m[r] = new Array(b_num_cols);
                    for (let c = 0; c < b_num_cols; ++c) {
                        m[r][c] = 0;

                        for (let i = 0; i < a_num_cols; ++i) {
                            m[r][c] += a[r][i] * b[i][c];
                        }
                    }
                }
                return m;
            }

            print_matrix = (matrix) => {
                for(let i = 0; i < matrix.length; i++) {
                    for(let j = 0; j < matrix[0].length; j++) {
                        console.log(matrix[i][j] + " ");
                    }
                    console.log("new row");
                }
            }
        
            print_all_drawn_shapes = () => {
                console.log(canvas_shapes);
            }

            // this will be used to save shapes, I just need to re-work which numbers to use since I've altered some of the drawing methods
            save_shape = () => {
                switch(current_shape) {
                    case "circ":
                        canvas_shapes[current_index] = [current_shape, current_tool, [x_pressed, y_pressed, x_radius, y_radius, 0, 2 * Math.PI, 0, 0]];
                        current_index++;
                        break;
                    case "line":
                        canvas_shapes[current_index] = [current_shape, current_tool, [x_pressed, y_pressed, x_move, y_move, 0, 0]];
                        current_index++;
                        break;
                    case "rect":
                        canvas_shapes[current_index] = [current_shape, current_tool, [x_pressed, y_pressed, x_move - x_pressed, y_move - y_pressed, 0, 0]];
                        current_index++;
                        break;
                    default:
                        console.log("Error: no shape selected.");
                        break;
                }
            }
        </script>

        <style>
            canvas {
                border: 2px solid black;
                float: left
            }

            td {
                padding: 10px;
            }

            #left-side {
                float: left;
            }

            #tools {
                float: right;
                width: 50%;
            }
        </style>
    </head>
    <body onload="draw(); disable_current_button();" onmousedown="mouse_pressed(event)" onmouseup="mouse_released(event)" onmousemove="mouse_move(event)">
        <div id="left-side">
            <div id='canvas-wrapper'>
                <canvas width="600" height="600" id="canvas">
                    Error: canvas is not supported by this browser.
                </canvas>
            </div>

            <div id='debug'>
                <table>
                    <tbody>
                        <tr><td><h2>mouse pressed = <span id='status'></span></h2></td><td><h2>mouse move</h2></td><td><h2>mouse released</h2></td></tr>
                        <tr><td><span>x: </span><span id='mouse_pressed_x'></span></td><td><span>x: </span><span id='mouse_move_x'></span></td><td><span>x: </span><span id='mouse_released_x'></span></td></tr>
                        <tr><td><span>y: </span><span id='mouse_pressed_y'></span></td><td><span>y: </span><span id='mouse_move_y'></span></td><td><span>y: </span><span id='mouse_released_y'></span></td></tr>
                    </tbody>
                </table>
            </div>
        </div>
        <div id="tools">
            <div id="tools-shapes">
                <h2>shapes</h2>
                <button onclick="set_current_shape(this.value); disable_current_button();" type="button" value="rect">Rectangle</button>
                <button onclick="set_current_shape(this.value); disable_current_button();" type="button" value="circ">Circle</button>
                <button onclick="set_current_shape(this.value); disable_current_button();" type="button" value="line">Line</button>
            </div>

            <div id="tools-shape-size">
                <h2>shape size</h2>
                <input type='range' min='1' max='600' value='5' id='shape-size-input' onchange="display_size()"/>
                <div id='shape-size-output'></div>
            </div>

            <div id="tools-transformations">
                <h2>transformations</h2>
                <button onclick="set_current_tool(this.value); disable_current_button();" type="button" value="scale">Scale</button>
                <button onclick="set_current_tool(this.value); disable_current_button();" type="button" value="rotate">Rotate</button>
                <button onclick="set_current_tool(this.value); disable_current_button();" type="button" value="translate">Translate</button>
            </div>
        </div>
    </body>
</html>