<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <title>Shape Editor</title>
        <link rel="stylesheet" type="text/css" href="main.css">
        <script src="shapes.js" type="application/javascript"></script>
        <script type="text/javascript">
            var DEBUG = false;

            var pageMarginX = 40;
            var pageMarginY = 65;
            
            var keysPressed = new Array();

            var currentFill = '#000000';
            var currentShape = 'plin';
            var currentHeight = 10;
            var currentWidth = 10;
            var currentStroke = '#000000';
            var currentTool = 'tran';

            var selectMode = false;
            var selectedShape = -1;
            var editedShape = null;

            var tempShape = []; // used for saving the currently drawn shape
            var drawing = false;
            var currentPLine = 0;
            var pLine = [];

            var Canvas = {
                drawnShapes : new Array(),
                gridSize : 10, // this could be an option in a future Settings page
                size : 600,
                undoCache: new Array(),

                clear : () => {
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    Canvas.drawGrid();
                },

                draw : () => {
                    canvas = document.getElementById('canvas');
                    context = canvas.getContext('2d');

                    Mouse.isPressed = false;
                    Canvas.clear();
                    setCurrentShape(currentShape);
                    setCurrentSize(currentWidth, currentHeight);
                    UI.disableCurrentButton();
                    UI.switchDisplayMode();
                    setCurrentFill();
                    setCurrentStroke();
                },

                drawGrid : () => {
                    for(let i = 0; i <= Canvas.size; i+=Canvas.gridSize) {
                        context.beginPath();
                        context.moveTo(i, 1);
                        context.lineTo(i, Canvas.size);
                        context.closePath();

                        context.strokeStyle = "#e0e0ff";
                        context.lineWidth = 1;
                        context.stroke();
                    }

                    for(let i = 0; i <= Canvas.size; i+=Canvas.gridSize) {
                        context.beginPath();
                        context.moveTo(1, i);
                        context.lineTo(Canvas.size, i);
                        context.closePath();

                        context.strokeStyle = "#e0e0ff";
                        context.lineWidth = 1;
                        context.stroke();
                    }
                },

                drawPrevious : () => {
                    tempTool = currentTool;
                    tempFill = currentFill;
                    tempStroke = currentStroke;

                    Canvas.drawnShapes.forEach((shape) => {
                        currentTool = shape[Enum.SHAPE_TOOL];

                        switch(shape[Enum.SHAPE_TYPE]) {
                            case "circ":
                                let tempCirc = new Circle();
                                tempCirc.load(shape[Enum.SHAPE_DEF]);
                                tempCirc.draw();
                                break;
                            case "curv":
                                let tempCurv = new Curve();
                                tempCurv.load(shape[Enum.SHAPE_DEF]);
                                tempCurv.draw(false, false);
                                break;
                            case "elli":
                                let tempElli = new Ellipse();
                                tempElli.load(shape[Enum.SHAPE_DEF]);
                                tempElli.draw();
                                break;
                            case "line":
                                let tempLine = new Line();
                                tempLine.load(shape[Enum.SHAPE_DEF]);
                                tempLine.draw(false, false);
                                break;
                            case "pgon":
                                let tempPolygon = new Polygon();
                                tempPolygon.load(shape[Enum.SHAPE_DEF]);
                                tempPolygon.draw();
                                break;
                            case "plin":
                                let tempPolyLine = new Polyline();
                                tempPolyLine.load(shape[Enum.SHAPE_DEF]);
                                tempPolyLine.draw();
                                break;
                            case "rect":
                                let tempRect = new Rectangle();
                                tempRect.load(shape[Enum.SHAPE_DEF]);
                                tempRect.draw();
                                break;
                            case "squa":
                                let tempSquare = new Square();
                                tempSquare.load(shape[Enum.SHAPE_DEF]);
                                tempSquare.draw();
                                break;
                            case "tria":
                                let tempTriangle = new Triangle();
                                tempTriangle.load(shape[Enum.SHAPE_DEF]);
                                tempTriangle.draw();
                                break;
                            default:
                                console.log("Error -> Canvas.drawPrevious(): no shape definition for " + shape[Enum.SHAPE_TYPE] + ".");
                                break;
                        }
                    });

                    currentTool = tempTool;
                    currentStroke = tempStroke;
                    currentFill = tempFill;
                },

                redo : () => {
                    if(!!Canvas.undoCache[0]) {
                        let poppedShape = Canvas.undoCache.pop();
                        Canvas.drawnShapes.push(poppedShape);
                        Canvas.clear();
                        Canvas.drawPrevious();
                    }
                },

                reset : () => {
                    let shouldClear = confirm("Are you sure you want to clear the canvas? This will delete your entire drawing.");

                    if(shouldClear) {
                        Canvas.clear();
                        Canvas.drawnShapes = new Array();
                    } else {

                    }
                },

                undo : () => {
                    if(!!Canvas.drawnShapes[0]) {
                        let poppedShape = Canvas.drawnShapes.pop()
                        Canvas.undoCache.push(poppedShape);
                        Canvas.clear();
                        Canvas.drawPrevious();
                    }
                },
            }

            var Enum = {
                SHAPE_TYPE      : 0,
                SHAPE_TOOL      : 1,
                SHAPE_DEF       : 2,
            }

            var File = {
                exportAsPNG : () => {
                    let canvasData = canvas.toDataURL();
                    let link = document.createElement("a");
                    link.href = canvasData;
                    link.download = 'shapes_image';
                    link.click();
                },

                load : () => {
                    let fileInput = document.createElement("input");
                    fileInput.type = "file";
                    fileInput.accept = "application/json";
                    fileInput.onchange = () => {
                        let fileReader = new FileReader();
                        let file = fileInput.files[0];

                        fileReader.onload = () => {
                            let loadedText = fileReader.result;
                            let loadedJSON = JSON.parse(loadedText);
                            Canvas.clear();
                            Canvas.drawnShapes = loadedJSON;
                            Canvas.drawPrevious();
                        }

                        fileReader.readAsText(file);
                    }

                    fileInput.click();
                },

                save : () => {
                    let jsonShapeData = JSON.stringify(Canvas.drawnShapes);
                    let link = document.createElement("a");
                    let file = new Blob([jsonShapeData], {type : 'application/json'});
                    link.href = URL.createObjectURL(file);
                    link.download = 'shapes';
                    link.click();
                }
            }

            var Key = {
                ctrl : 17,
                del : 46,
                shift : 16,
                tilde : 192,
                e : 69,
                o : 79,
                r : 82,
                s : 83,
                z : 90,

                // -- I got the algorithm for this solution from https://stackoverflow.com/questions/5203407/how-to-detect-if-multiple-keys-are-pressed-at-once-using-javascript#answer-12444641
                checkMultipleKeyPresses : (event) => {
                    keysPressed[event.keyCode] = event.type == 'keydown';
                },

                checkPressed : (key) => {
                    return keysPressed[key];
                },

                keyboardExport : () => {
                    if (keysPressed[Key.ctrl] && keysPressed[Key.e]) {
                        File.exportAsPNG();
                    }
                },

                keyboardLoad : () => {
                    if (keysPressed[Key.ctrl] && keysPressed[Key.o]) {
                        File.load();
                    }
                }, 
                
                keyboardRedo : () => {
                    if (keysPressed[Key.ctrl] && keysPressed[Key.shift] && keysPressed[Key.z]) {
                        Canvas.redo();
                    }
                },

                // keyboardRefresh : () => {
                //     if(keysPressed[Key.ctrl] && keysPressed[Key.r]) {
                //         location.reload();
                //     }
                // },

                // keyboardResetCanvas : () => {
                //     if (keysPressed[Key.ctrl] && keysPressed[Key.del]) {
                //         Canvas.reset();
                //     }
                // },

                // keyboardSave : (event) => {
                //     event.preventDefault();
                //     if(keysPressed[Key.ctrl] && keysPressed[Key.s]) {
                //         File.save();
                //     }
                // },

                keyboardSwitchDisplayMode : () => {
                    if (keysPressed[Key.ctrl] && keysPressed[Key.tilde]) {
                        UI.switchDisplayMode(!UI.darkMode);
                    }
                },

                keyboardUndo : () => {
                    if (keysPressed[Key.ctrl] && keysPressed[Key.z] && !keysPressed[Key.shift]) {
                        Canvas.undo();
                    }
                },
            }

            var Matrix = {
                multiply : (a, b) => {
                    let aNumRows = a.length;
                    let aNumCols = a[0].length;
                    let bNumCols = b[0].length;
                    let m = new Array(aNumRows);

                    for (let r = 0; r < aNumRows; ++r) {
                        m[r] = new Array(bNumCols);
                        for (let c = 0; c < bNumCols; ++c) {
                            m[r][c] = 0;

                            for (let i = 0; i < aNumCols; ++i) {
                                m[r][c] += a[r][i] * b[i][c];
                            }
                        }
                    }
                    return m;
                },

                print : (matrix) => {
                    for(let i = 0; i < matrix.length; i++) {
                        for(let j = 0; j < matrix[0].length; j++) {
                            console.log(matrix[i][j] + " ");
                        }
                        console.log("new row");
                    }
                },
            }

            var Mouse = {
                isPressed : false,
                moveX : 0,
                moveY : 0,
                overCanvas : false,
                pressedX : 0,
                pressedY : 0,
                releasedX : 0,
                releasedY : 0,

                checkSelect : () => {
                    let foundShape = false;
                    tempTool = currentTool;
                    tempFill = currentFill;
                    tempStroke = currentStroke;
                    
                    for(let i = Canvas.drawnShapes.length - 1; i >= 0 && !foundShape; i--) {
                        let shape = Canvas.drawnShapes[i];
                        let temp = new Shape();

                        currentTool = shape[Enum.SHAPE_TOOL];

                        switch(shape[Enum.SHAPE_TYPE]) {
                            case "circ":
                                temp = new Circle();
                                break;
                            case "curv":
                                temp = new Curve();
                                break;
                            case "elli":
                                temp = new Ellipse();
                                break;
                            case "line":
                                temp = new Line();
                                break;
                            case "pgon":
                                temp = new Polygon();
                                break;
                            case "plin":
                                temp = new Polyline();
                                break;
                            case "rect":
                                temp = new Rectangle();
                                break;
                            case "squa":
                                temp = new Square();
                                break;
                            case "tria":
                                temp = new Triangle();
                                break;
                            default:
                                console.log("Error -> Canvas.drawPrevious(): no shape definition for " + shape[Enum.SHAPE_TYPE] + ".");
                                break;
                        }

                        temp.load(shape[Enum.SHAPE_DEF]);
                        temp.loadIntoContext();
                        context.strokeStyle = "cccccc";
                        context.stroke();
                        context.strokeStyle = this.strokeColor;

                        if(shape[Enum.SHAPE_TYPE] == 'line' || shape[Enum.SHAPE_TYPE] == 'curv' || shape[Enum.SHAPE_TYPE] == 'plin') {
                            context.lineWidth = 5;

                            if(context.isPointInStroke(Mouse.pressedX, Mouse.pressedY)) {
                                // console.log("index [" + i + "]: " + shape);
                                foundShape = true;
                                selectedShape = i;
                            }
                        } else {
                            if(context.isPointInPath(Mouse.pressedX, Mouse.pressedY)) {
                                // console.log("index [" + i + "]: " + shape);
                                foundShape = true;
                                selectedShape = i;
                            } 
                        }

                        context.lineWidth = 1;
                    }

                    currentTool = tempTool;
                    currentStroke = tempStroke;
                    currentFill = tempFill;
                },

                pressed : (event) => {
                    Mouse.overCanvas = event.pageX - pageMarginX >= 0 && event.pageX - pageMarginX <= Canvas.size && event.pageY - pageMarginY >= 0 && event.pageY - pageMarginY <= Canvas.size;

                    if(Mouse.overCanvas) {
                        Mouse.pressedX = event.pageX - pageMarginX;
                        Mouse.pressedY = event.pageY - pageMarginY;

                        Mouse.isPressed = true;

                        if(selectMode) {
                            Mouse.checkSelect();
                        } else {
                            if((currentShape == 'plin' || currentShape == 'pgon') && Key.checkPressed(Key.ctrl) && currentPLine == 0) {
                                drawing = true;

                                if(currentShape == 'plin') {
                                    tempShape = new Polyline(Mouse.pressedX, Mouse.pressedY, [], currentStroke);
                                } else {
                                    tempShape = new Polygon(Mouse.pressedX, Mouse.pressedY, [], currentStroke, currentFill);
                                }

                                tempShape.startDraw();
                                currentPLine++;
                            } else if ((currentShape == 'plin' || currentShape == 'pgon') && Key.checkPressed(Key.ctrl) && drawing) {
                                tempShape.addLine(Mouse.pressedX, Mouse.pressedY);
                            }
                        }

                        document.getElementById('mouse_pressed_x').innerHTML = Mouse.pressedX;
                        document.getElementById('mouse_pressed_y').innerHTML = Mouse.pressedY;
                        document.getElementById('status').innerHTML = Mouse.isPressed;
                    }
                },

                move : (event) => {
                    Mouse.moveX = event.pageX - pageMarginX;
                    Mouse.moveY = event.pageY - pageMarginY;

                    if(Mouse.isPressed && !selectMode) {
                        Canvas.clear();
                        Canvas.drawPrevious();

                        switch(currentShape) {
                            case "circ":
                                tempShape = new Circle(Mouse.pressedX, Mouse.pressedY, currentWidth / 2, Mouse.moveX, Mouse.moveY, currentStroke, currentFill);
                                tempShape.draw();
                                break;
                            case "curv":
                                tempShape = new Curve(Mouse.pressedX, Mouse.pressedY, currentWidth, currentHeight, Mouse.moveX, Mouse.moveY, currentStroke);
                                tempShape.draw(false);
                                break;
                            case "elli":
                                tempShape = new Ellipse(Mouse.pressedX, Mouse.pressedY, currentWidth / 2, currentHeight / 2, Mouse.moveX, Mouse.moveY, currentStroke);
                                tempShape.draw();
                                break;
                            case "line":
                                tempShape = new Line(Mouse.pressedX, Mouse.pressedY, Mouse.pressedX + currentWidth, Mouse.pressedY + currentHeight, Mouse.moveX, Mouse.moveY, currentStroke);
                                tempShape.draw(false);
                                break;
                            case "pgon":
                                if(Key.checkPressed(Key.ctrl) && drawing) {
                                    tempShape.drawTemp(Mouse.moveX, Mouse.moveY);
                                }
                                break;
                            case "plin":
                                if(Key.checkPressed(Key.ctrl) && drawing) {
                                    tempShape.drawTemp(Mouse.moveX, Mouse.moveY);
                                }
                                break;
                            case "rect":
                                tempShape = new Rectangle(Mouse.pressedX, Mouse.pressedY, currentWidth, currentHeight, Mouse.moveX, Mouse.moveY, currentStroke, currentFill);
                                tempShape.draw();
                                break;
                            case "squa":
                                tempShape = new Square(Mouse.pressedX, Mouse.pressedY, currentWidth, Mouse.moveX, Mouse.moveY, currentStroke, currentFill);
                                tempShape.draw();
                                break;
                            case "tria":
                                tempShape = new Triangle(Mouse.pressedX, Mouse.pressedY, currentWidth, currentHeight, Mouse.moveX, Mouse.moveY, currentStroke, currentFill);
                                tempShape.draw();
                                break;
                            default:
                                console.log("Error: no shape selected.");
                                break;
                        }
                        

                    } else if(Mouse.isPressed && selectMode) {
                        Canvas.clear();
                        Canvas.drawPrevious();

                        if(selectedShape != -1 && !!Canvas.drawnShapes[selectedShape]) {
                            let shape = null;
                            tempTool = currentTool;
                            currentTool = Canvas.drawnShapes[selectedShape][Enum.SHAPE_TOOL];

                            switch(Canvas.drawnShapes[selectedShape][Enum.SHAPE_TYPE]) {
                                case "circ":
                                    shape = new Circle();
                                    break;
                                case "curv":
                                    shape = new Curve();
                                    break;
                                case "elli":
                                    shape = new Ellipse();
                                    break;
                                case "line":
                                    shape = new Line();
                                    break;
                                case "pgon":
                                    shape = new Polygon();
                                    break;
                                case "plin":
                                    shape = new Polyline();
                                    break;
                                case "rect":
                                    shape = new Rectangle();
                                    break;
                                case "squa":
                                    shape = new Square();
                                    break;
                                case "tria":
                                    shape = new Triangle();
                                    break;
                                default:
                                    console.log("Error -> Canvas.drawPrevious(): no shape definition for " + Canvas.drawnShapes[selectedShape][Enum.SHAPE_TYPE] + ".");
                                    break;
                            }
                            
                            shape.load(Canvas.drawnShapes[selectedShape][Enum.SHAPE_DEF]);
                            shape.transform();

                            currentTool = tempTool;
                            shape.edit(Mouse.pressedX, Mouse.pressedY, Mouse.moveX, Mouse.moveY);
                            editedShape = shape.toString();

                            // add new stroke color to make it easier to tell what the transformation will do to the shape
                            let originalStroke = shape.strokeColor;
                            shape.strokeColor = "#ff0000";
                            shape.draw(false);
                            shape.strokeColor = originalStroke;
                        }
                    }

                    document.getElementById('mouse_move_x').innerHTML = Mouse.moveX;
                    document.getElementById('mouse_move_y').innerHTML = Mouse.moveY;
                    document.getElementById('status').innerHTML = Mouse.isPressed;
                },

                released : (event) => {
                    Mouse.overCanvas = event.pageX - pageMarginX >= 0 && event.pageX - pageMarginX <= Canvas.size && event.pageY - pageMarginY >= 0 && event.pageY - pageMarginY <= Canvas.size;

                    if(Mouse.overCanvas) {
                        Mouse.releasedX = event.pageX - pageMarginX;
                        Mouse.releasedY = event.pageY - pageMarginY;

                        Mouse.isPressed = false;

                        if(!!tempShape && !selectMode && (currentShape != 'plin' && currentShape != 'pgon')) {
                            tempShape.save();
                            tempShape = null;
                        } else if (!!tempShape && !selectMode && (currentShape == 'plin' || currentShape == 'pgon') && !Key.checkPressed(Key.ctrl)) {
                            tempShape.save();
                            drawing = false;
                            currentPLine = 0;
                            tempShape = null;
                        } else if (selectMode && editedShape != null) {
                            Canvas.drawnShapes[selectedShape][Enum.SHAPE_TOOL] = currentTool; // this doesn't make the right changes sometimes...?
                            Canvas.drawnShapes[selectedShape][Enum.SHAPE_DEF] = editedShape.toString();
                            // console.log(Canvas.drawnShapes);
                            selectedShape = -1;
                            editedShape = null;
                        }
                    }

                    Canvas.clear();
                    Canvas.drawPrevious();
                    
                    document.getElementById('mouse_released_x').innerHTML = Mouse.releasedX;
                    document.getElementById('mouse_released_y').innerHTML = Mouse.releasedY;
                    document.getElementById('status').innerHTML = Mouse.isPressed;
                }
            };

            var Trig = {
                calculateRotation : (x0, y0, x1, y1) => {
                    // -- found this at: https://stackoverflow.com/questions/21483999/using-atan2-to-find-angle-between-two-vectors#answer-21484228
                    return Math.atan2(y1 - y0, x1 - x0);
                },

                degreesToRadians : (degrees) => {
                    return degrees * Math.PI / 180;
                },

                radiansToDegrees : (radians) => {
                    return radians * 180 / Math.PI;
                }
            }

            var UI = {
                darkMode : true,

                disableCurrentButton : () => {
                    let buttons = document.getElementsByTagName("button");
                    
                    for (let i = 0; i < buttons.length; ++i) {
                        if(buttons[i].value == currentShape || buttons[i].value == currentTool) {
                            buttons[i].disabled = true;
                        } else {
                            buttons[i].disabled = false;
                        }
                    }

                    UI.switchDisplayMode();
                },

                switchDisplayMode : (mode = UI.darkMode) => {
                    UI.darkMode = mode;

                    if(UI.darkMode) {
                        // anchors
                        let anchorElements = document.getElementsByTagName('a');
                        for(let i = 0; i < anchorElements.length; ++i) {
                            anchorElements[i].style.color = "#448AFF";
                        }

                        // body
                        let bodyElement = document.getElementsByTagName('body');
                        bodyElement[0].style.backgroundColor = "#303030";
                        bodyElement[0].style.color = "#ffffff";

                        // buttons
                        let buttonElements = document.getElementsByTagName('button');
                        for(let i = 0; i < buttonElements.length; ++i) {
                            if(buttonElements[i].id != "select-mode-disabled" && buttonElements[i].id != "select-mode-enabled"){
                                if(buttonElements[i].disabled) {
                                    buttonElements[i].style.backgroundColor = "#a5a5a5";
                                    buttonElements[i].style.borderColor = "#636363";
                                    buttonElements[i].style.color = "#636363";
                                } else {
                                    buttonElements[i].style.backgroundColor = "#424242";
                                    buttonElements[i].style.borderColor = "#448AFF";
                                    buttonElements[i].style.color = "#448AFF";
                                }
                            }
                        }

                        // select mode
                        if(selectMode) {
                            let selectButton = document.getElementById("select-mode-enabled");

                            selectButton.style.color = "#636363";
                            selectButton.style.backgroundColor = "#a5a5a5";
                            selectButton.style.borderColor = "#636363";
                        } else {
                            let selectButton = document.getElementById("select-mode-disabled");

                            selectButton.style.color = "#448aff";
                            selectButton.style.backgroundColor = "#424242";
                            selectButton.style.borderColor = "#448aff";
                        }

                        // section
                        let sections = document.getElementsByClassName('section');
                        for(let i = 0; i < sections.length; ++i) {
                            if(sections[i].id != "debug") {
                                sections[i].style.backgroundColor = "#424242";
                                sections[i].style.color = "#ffffff";
                            }
                        }

                        // blue bars
                        let bluebars = document.getElementsByClassName('blue-bar');
                        for(let i = 0; i < bluebars.length; ++i) {
                            bluebars[i].style.color = "#448AFF";
                        }

                        // shape size input
                        let shapeHeightInput = document.getElementById('shape-height-text');
                        let shapeWidthInput = document.getElementById('shape-width-text');
                        shapeHeightInput.style.border = "none";
                        shapeWidthInput.style.border = "none";

                        // toolbar
                        let toolbar = document.getElementById("toolbar");
                        toolbar.style.backgroundColor = "#212121";
                        toolbar.style.color = "#448AFF";

                        // dark / light mode buttons
                        let darkModeButton = document.getElementById("dark-mode-button-dark");
                        let lightModeButton = document.getElementById("dark-mode-button-light");

                        darkModeButton.disabled = true;
                        lightModeButton.disabled = false;

                        // button group buttons
                        let buttonGroupButtonElements = document.getElementsByClassName('button-group-button');
                        for(let i = 0; i < buttonGroupButtonElements.length; ++i) {
                            buttonGroupButtonElements[i].style.backgroundColor = "inherit";

                            if(buttonGroupButtonElements[i].disabled) {
                                buttonGroupButtonElements[i].style.color = "#636363";
                            } else {
                                buttonGroupButtonElements[i].style.color = "#448AFF";
                            }
                        }

                        // button group
                        let buttonGroup = document.getElementsByClassName('button-group');
                        for(let i = 0; i < buttonGroup.length; ++i) {
                            buttonGroup[i].style.borderColor = "#448AFF";
                        }
                        
                        // slider inputs
                        let sliderInputs = document.getElementsByTagName("input");
                        for(let i = 0; i < sliderInputs.length; ++i) {
                            if(sliderInputs[i].type == "range") {
                                sliderInputs[i].style.backgroundColor = "#424242";
                            }
                        }
                    } else {
                        // anchors
                        let anchorElements = document.getElementsByTagName('a');
                        for(let i = 0; i < anchorElements.length; ++i) {
                            anchorElements[i].style.color = "#000000";
                        }

                        // body
                        let bodyElement = document.getElementsByTagName('body');
                        bodyElement[0].style.backgroundColor = "#dedede";
                        bodyElement[0].style.color = "#000000";

                        // buttons
                        let buttonElements = document.getElementsByTagName('button');
                        for(let i = 0; i < buttonElements.length; ++i) {
                            if(buttonElements[i].disabled) {
                                buttonElements[i].style.backgroundColor = "#448AFF";
                                buttonElements[i].style.borderColor = "#000000";
                                buttonElements[i].style.color = "#000000";
                            } else {
                                buttonElements[i].style.backgroundColor = "#ffffff";
                                buttonElements[i].style.borderColor = "#448AFF";
                                buttonElements[i].style.color = "#000000";
                            }
                        }

                        // select mode
                        if(selectMode) {
                            let selectButton = document.getElementById("select-mode-enabled");

                            selectButton.style.color = "#000000";
                            selectButton.style.backgroundColor = "#448aff";
                            selectButton.style.borderColor = "#000000";
                        } else {
                            let selectButton = document.getElementById("select-mode-disabled");

                            selectButton.style.color = "#000000";
                            selectButton.style.backgroundColor = "#ffffff";
                            selectButton.style.borderColor = "#448aff";
                        }

                        // shape size input
                        let shapeHeightInput = document.getElementById('shape-height-text');
                        let shapeWidthInput = document.getElementById('shape-width-text');
                        shapeHeightInput.style.borderWidth = "1px";
                        shapeHeightInput.style.borderColor = "#448AFF";
                        shapeHeightInput.style.borderStyle = "solid";
                        shapeWidthInput.style.borderWidth = "1px";
                        shapeWidthInput.style.borderColor = "#448AFF";
                        shapeWidthInput.style.borderStyle = "solid";
                        
                        // section
                        let sections = document.getElementsByClassName('section');
                        for(let i = 0; i < sections.length; ++i) {
                            if(sections[i].id != "debug") {
                                sections[i].style.backgroundColor = "#ffffff";
                                sections[i].style.color = "#000000";
                            }
                        }

                        // blue bars
                        let bluebars = document.getElementsByClassName("blue-bar");
                        for(let i = 0; i < bluebars.length; ++i) {
                            bluebars[i].style.color = "#000000";
                        }

                        // toolbar
                        let toolbar = document.getElementById("toolbar");
                        toolbar.style.backgroundColor = "#bdbdbd";
                        toolbar.style.color = "#000000";

                        // dark / light mode buttons
                        let darkModeButton = document.getElementById("dark-mode-button-dark");
                        let lightModeButton = document.getElementById("dark-mode-button-light");

                        darkModeButton.disabled = false;
                        lightModeButton.disabled = true;

                        // button group buttons
                        let buttonGroupButtonElements = document.getElementsByClassName('button-group-button');
                        for(let i = 0; i < buttonGroupButtonElements.length; ++i) {
                            buttonGroupButtonElements[i].style.backgroundColor = "inherit";

                            if(buttonGroupButtonElements[i].disabled) {
                                buttonGroupButtonElements[i].style.color = "#636363";
                            } else {
                                buttonGroupButtonElements[i].style.color = "#000000";
                            }
                        }

                        // button group
                        let buttonGroup = document.getElementsByClassName('button-group');
                        for(let i = 0; i < buttonGroup.length; ++i) {
                            buttonGroup[i].style.borderColor = "#000000";
                        }
                        
                        // slider inputs
                        let sliderInputs = document.getElementsByTagName("input");
                        for(let i = 0; i < sliderInputs.length; ++i) {
                            if(sliderInputs[i].type == "range") {
                                sliderInputs[i].style.backgroundColor = "#ffffff";
                            }
                        }
                    }
                },
            }

            setCurrentFill = () => {
                red = parseInt(document.getElementById('shape-fill-color-range-r').value).toString(16);
                red = red.length == 1 ? "0" + red : red;

                green = parseInt(document.getElementById('shape-fill-color-range-g').value).toString(16);
                green = green.length == 1 ? "0" + green : green;

                blue = parseInt(document.getElementById('shape-fill-color-range-b').value).toString(16);
                blue = blue.length == 1 ? "0" + blue : blue;

                currentFill = "#" + red + green +  blue;
                document.getElementById('shape-fill-color-text').value = currentFill;
                document.getElementById('shape-fill-color-text').style.backgroundColor = currentFill;
            }

            setCurrentShape = (shape) => {
                currentShape = shape;
                UI.switchDisplayMode();

                if(shape == 'circ' || shape == 'squa') {
                    currentWidth = currentWidth >= currentHeight ? currentWidth : currentHeight;
                    currentHeight = currentHeight >= currentWidth ? currentHeight : currentWidth;
                    setCurrentSize(currentWidth, currentHeight);
                }
            }

            setCurrentSize = (width, height) => {
                if(width == currentWidth && (currentShape == 'circ' || currentShape == 'squa')) {
                    currentWidth = parseInt(height);
                } else {
                    currentWidth = parseInt(width);
                }

                if(height == currentHeight && (currentShape == 'circ' || currentShape == 'squa')) {
                    currentHeight = parseInt(width);
                } else {
                    currentHeight = parseInt(height);
                }

                document.getElementById('shape-width-range').value = currentWidth;
                document.getElementById('shape-height-range').value = currentHeight;
                document.getElementById('shape-width-text').value = currentWidth;
                document.getElementById('shape-height-text').value = currentHeight;
            }

            setCurrentStroke = () => {
                red = parseInt(document.getElementById('shape-stroke-color-range-r').value).toString(16);
                red = red.length == 1 ? "0" + red : red;

                green = parseInt(document.getElementById('shape-stroke-color-range-g').value).toString(16);
                green = green.length == 1 ? "0" + green : green;

                blue = parseInt(document.getElementById('shape-stroke-color-range-b').value).toString(16);
                blue = blue.length == 1 ? "0" + blue : blue;

                currentStroke = "#" + red + green +  blue;
                document.getElementById('shape-stroke-color-text').value = currentStroke;
                document.getElementById('shape-stroke-color-text').style.backgroundColor = currentStroke;
            }

            setCurrentTool = (tool) => {
                currentTool = tool;
                UI.switchDisplayMode();
            }

            setSelectMode = (mode) => {
                selectMode = mode;

                if(selectMode) {
                    let selectButton = document.getElementById("select-mode-disabled");
                    selectButton.id = "select-mode-enabled";
                } else {
                    let selectButton = document.getElementById("select-mode-enabled");
                    selectButton.id = "select-mode-disabled";
                }

                UI.switchDisplayMode();
            }
        </script>
    </head>
    <body onload="Canvas.draw(); UI.disableCurrentButton();" onmousedown="Mouse.pressed(event);" onmouseup="Mouse.released(event);" onmousemove="Mouse.move(event);" onkeydown="Key.checkMultipleKeyPresses(event); Key.keyboardUndo(); Key.keyboardRedo();Key.keyboardSwitchDisplayMode();" onkeyup="Key.checkMultipleKeyPresses(event);">
        <div id="toolbar">
            <a onclick="File.save();">Save</a>
            <a onclick="File.load();">Load</a>
            <a onclick="File.exportAsPNG();">Export as PNG</a>
            <span class="blue-bar">|</span>
            <a onclick="Canvas.undo()">Undo</a>
            <a onclick="Canvas.redo();">Redo</a>
            <span class="blue-bar">|</span>
            <a onclick="Canvas.reset();">Clear Canvas</a>
            <span class="button-group">
                <button class="button-group-button" id="dark-mode-button-dark" onclick="UI.switchDisplayMode(true);">☽</a>
                <button disabled class="button-group-button"id="dark-mode-button-light" onclick="UI.switchDisplayMode(false);">☼</a>
            </span>
        </div>
        <div id="left-side">
            <div id='canvas-wrapper'>
                <canvas width="600" height="600" id="canvas" download>
                    Error: canvas is not supported by this browser.
                </canvas>
            </div>

            <div id='debug' class="section">
                <table>
                    <tbody>
                        <tr><td><h3>rotation = <span id='rotation'></span></h3></td></tr>
                        <tr><td><h3>mouse pressed = <span id='status'></span></h3></td><td><h3>mouse move</h3></td><td><h3>mouse released</h3></td></tr>
                        <tr><td><span>x: </span><span id='mouse_pressed_x'></span></td><td><span>x: </span><span id='mouse_move_x'></span></td><td><span>x: </span><span id='mouse_released_x'></span></td></tr>
                        <tr><td><span>y: </span><span id='mouse_pressed_y'></span></td><td><span>y: </span><span id='mouse_move_y'></span></td><td><span>y: </span><span id='mouse_released_y'></span></td></tr>
                    </tbody>
                </table>
            </div>
        </div>
        <div id="tools">
            <div id="tools-transformations" class="section">
                <h2>transformations</h2>
                <button id="select-mode-disabled" onclick="setSelectMode(!selectMode);" type="button" value="sele">Select</button>
                <span class="blue-bar">|</span>
                <button onclick="setCurrentTool(this.value); UI.disableCurrentButton();" type="button" value="rota">Rotate</button>
                <button onclick="setCurrentTool(this.value); UI.disableCurrentButton();" type="button" value="scal">Scale</button>
                <button onclick="setCurrentTool(this.value); UI.disableCurrentButton();" type="button" value="tran">Translate</button>
            </div>

            <div id="tools-shapes" class="section">
                <h2>shapes</h2>
                <button onclick="setCurrentShape(this.value); UI.disableCurrentButton();" type="button" value="circ">Circle</button>
                <button onclick="setCurrentShape(this.value); UI.disableCurrentButton();" type="button" value="curv">Curve</button>
                <button onclick="setCurrentShape(this.value); UI.disableCurrentButton();" type="button" value="elli">Ellipse</button>
                <button onclick="setCurrentShape(this.value); UI.disableCurrentButton();" type="button" value="line">Line</button>
                <button onclick="setCurrentShape(this.value); UI.disableCurrentButton();" type="button" value="pgon">Polygon</button>
                <button onclick="setCurrentShape(this.value); UI.disableCurrentButton();" type="button" value="plin">Poly-Line</button>
                <button onclick="setCurrentShape(this.value); UI.disableCurrentButton();" type="button" value="rect">Rectangle</button>
                <button onclick="setCurrentShape(this.value); UI.disableCurrentButton();" type="button" value="squa">Square</button>
                <button onclick="setCurrentShape(this.value); UI.disableCurrentButton();" type="button" value="tria">Triangle</button>
            </div>

            <div id="tools-shape-parameters" class="section">
                <table>
                    <tr>
                        <td>
                            <h2>shape size</h2>
                        </td>
                        <td>
                            <h2>fill color</h2>
                        </td>
                        <td>
                            <h2>stroke color</h2>
                        </td>
                    </tr>
                    <tr>
                        <td class="rgb-range">
                            <input style="width: 35%" type='text' value='10' id='shape-width-text' onchange="setCurrentSize(this.value, currentHeight)"/>
                            x
                            <input style="width: 35%" type='text' value='10' id='shape-height-text' onchange="setCurrentSize(currentWidth, this.value)"/>
                        </td>
                        <td class="rgb-range">
                            <input disabled type='text' id='shape-fill-color-text' value="#000000"/><br>
                        </td>
                        <td class="rgb-range">
                            <input disabled type='text' id='shape-stroke-color-text' onchange="setCurrentStroke(this.value)" value="#000000"/>
                        </td>
                        <td>
                            
                        </td>
                    </tr>
                    <tr>
                        <td class="rgb-range">
                            width: <input type='range' min='1' max='600' value='5' id='shape-width-range' onchange="setCurrentSize(this.value, currentHeight)"/>
                        </td>
                        <td class="rgb-range">
                            red: <input type='range' min='0' max='255' value='0' id='shape-fill-color-range-r' onchange="setCurrentFill()" /><br>
                        </td>
                        <td class="rgb-range">
                            red: <input type='range' min='0' max='255' value='0' id='shape-stroke-color-range-r' onchange="setCurrentStroke()" /><br>
                        </td>
                    </tr>
                    <tr>
                        <td class="rgb-range">
                            height: <input type='range' min='1' max='600' value='5' id='shape-height-range' onchange="setCurrentSize(currentWidth, this.value)"/>
                        </td>
                        <td class="rgb-range">
                            green: <input type='range' min='0' max='255' value='0' id='shape-fill-color-range-g' onchange="setCurrentFill()" /><br>
                        </td>
                        <td class="rgb-range">
                            green: <input type='range' min='0' max='255' value='0' id='shape-stroke-color-range-g' onchange="setCurrentStroke()" /><br>
                        </td>
                    </tr>
                    <tr>
                        <td class="rgb-range">
                        </td>
                        <td class="rgb-range">
                            blue: <input type='range' min='0' max='255' value='0' id='shape-fill-color-range-b' onchange="setCurrentFill()" />
                        </td>
                        <td class="rgb-range">
                            blue: <input type='range' min='0' max='255' value='0' id='shape-stroke-color-range-b' onchange="setCurrentStroke()" />
                        </td>
                    </tr>
                </table>
            </div>

            <div id="instructions" class="section">
                <div id="inner-instructions">
                    <h2>instructions</h2>
                    <span>
                        <h3>drawing</h3>
                        <p>
                            <ul>
                                <li> click the <strong>Rotate button</strong> / <strong>Scale button</strong> / <strong>Translate button</strong> </li>
                                <li> click the button of the shape you would like to draw </li>
                                <li> draw something </li>
                            </ul>
                        </p>
                        <h3>poly-line / polygon drawing</h3>
                        <p>
                            <ul>
                                <li> to begin drawing a poly-line / polygon, hold CTRL and click the mouse where you would like the line to begin </li>
                                <li> keep CTRL and the mouse pressed and drag until you reach the point where you would like the current line to end. click the mouse (this will end the current line and begin the next line). </li>
                                <li> repeat this process until you are satisfied with the shape of the line. </li>
                                <li> to stop drawing a poly-line / polygon, release CTRL and click the mouse anywhere in the canvas. </li>
                            </ul>
                        </p>
                        <h3>selection</h3>
                        <p>
                            <ul>
                                <li> hit the <strong>select button</strong> </li>
                                <li> hit the transformation button that you would like to apply to the shape </li>
                                <li> click and hold the shape that you would like to edit </li>
                                <li> release the click to save your edit </li>
                            </ul>
                        </p>
                        <h3>keyboard shortcuts</h3>
                        <p>
                            <ul>
                                <li><strong>undo</strong> : CTRL + Z</li>
                                <li><strong>redo</strong> : CTRL + SHIFT + Z</li>
                                <li><strong>switch between light and dark mode</strong> : CTRL + `</li>
                            </ul>
                        </p>
                    </span>
                </div>
            </div>
        </div>
    </body>
</html>